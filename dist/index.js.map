{"version":3,"sources":["../src/index.ts","../src/authStore.ts","../src/errors.ts","../src/utils.ts","../src/loaderPolicyFunctions.ts"],"sourcesContent":["export { createAuthStore } from './authStore'\nexport { authorize, handleRedirectCallback } from './loaderPolicyFunctions'\nexport type { User } from './types'\nexport type {\n  Cacheable,\n  CacheLocation,\n  GetTokenSilentlyOptions,\n  GetTokenWithPopupOptions,\n  ICache,\n  IdToken,\n  InMemoryCache,\n  LocalStorageCache,\n  LogoutOptions,\n  LogoutUrlOptions,\n  PopupConfigOptions,\n  PopupLoginOptions,\n} from '@auth0/auth0-spa-js'\nexport { default as createAuthHook } from 'zustand'\n","import {\n  type Auth0ClientOptions,\n  type GetTokenSilentlyOptions,\n  type IdToken,\n  type LogoutOptions,\n  type RedirectLoginOptions,\n  Auth0Client,\n} from '@auth0/auth0-spa-js'\nimport { type StoreApi, type UseBoundStore, createStore } from 'zustand'\n\nimport type { Auth0User, User } from './types'\nimport { tokenError, transformSnakeObjectKeysToCamel } from './utils'\n\ntype AuthState = {\n  auth0Client: Auth0Client\n  isLoading: boolean\n  isAuthenticated: boolean\n  error?: Error\n  user?: User\n  initialised: (user?: Auth0User) => void\n  setError: (error: Error) => void\n  loginWithRedirect: (loginOptions?: RedirectLoginOptions) => Promise<void>\n  logout: (logoutOptions?: LogoutOptions) => Promise<void>\n  getAccessTokenSilently: (getTokenOptions?: GetTokenSilentlyOptions) => Promise<string>\n  getIdTokenClaims: () => Promise<IdToken | undefined>\n}\n\n/**\n *  Function factory to create the Zustand store that contains all the state and the different auth methods.\n *  Use this store outside the React tree (ie. `const { isAuthenticated, loginWithRedirect } = authStore.getState()`) or if you only need access to its methods.\n * ```js\n * const authStore = createAuthStore({\n *  domain: import.meta.env.VITE_AUTH0_DOMAIN,\n *  clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,\n *  useRefreshTokens: true,\n *  authorizationParams: {\n *    audience: import.meta.env.VITE_AUTH0_AUDIENCE,\n *    redirect_uri: window.location.origin,\n *  },\n * }\n * ```\n *\n * Then you can use the `createAuthHook` function to create a custom hook for easy access inside React components\n * ```js\n * const useAuth = createAuthHook(authStore)\n * ```\n */\nexport const createAuthStore = (options: Auth0ClientOptions) =>\n  createStore<AuthState>()((set, get) => ({\n    isLoading: true,\n    isAuthenticated: false,\n    auth0Client: new Auth0Client(options),\n    initialised: user =>\n      set(state => ({\n        ...state,\n        isAuthenticated: !!user,\n        user: user ? transformSnakeObjectKeysToCamel(user) : user,\n        isLoading: false,\n        error: undefined,\n      })),\n    setError: error => set(state => ({ ...state, isLoading: false, error })),\n    loginWithRedirect: loginOptions => {\n      const { auth0Client } = get()\n      return auth0Client.loginWithRedirect(loginOptions)\n    },\n    logout: logoutOptions => {\n      const { auth0Client } = get()\n      return auth0Client.logout(logoutOptions)\n    },\n    getAccessTokenSilently: async getTokenOptions => {\n      const { auth0Client } = get()\n      let token\n\n      try {\n        token = await auth0Client.getTokenSilently(getTokenOptions)\n      } catch (error: any) {\n        throw tokenError(error)\n      } finally {\n        const auth0User = await auth0Client.getUser<Auth0User>()\n        if (auth0User) {\n          const user = transformSnakeObjectKeysToCamel(auth0User)\n          set(state =>\n            state.user?.updatedAt === user.updatedAt\n              ? state\n              : { ...state, isAuthenticated: !!user, user },\n          )\n        }\n      }\n      return token\n    },\n    getIdTokenClaims: () => {\n      const { auth0Client } = get()\n      return auth0Client.getIdTokenClaims()\n    },\n  }))\n\nexport type AuthStore = ReturnType<typeof createAuthStore>\nexport type UseAuthHook = UseBoundStore<StoreApi<AuthState>>\n","/**\n * An OAuth2 error will come from the authorization server and will have at least an `error` property which will\n * be the error code. And possibly an `error_description` property\n *\n * See: https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.6\n */\nexport class OAuthError extends Error {\n  constructor(public error: string, public error_description?: string) {\n    super(error_description || error)\n\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, OAuthError.prototype)\n  }\n}\n","import { OAuthError } from './errors'\nimport { type CamelCasedProperties } from './types'\n\nconst normalizeErrorFn =\n  (fallbackMessage: string) =>\n  (error: Error | { error: string; error_description?: string } | ProgressEvent): Error => {\n    if ('error' in error) {\n      return new OAuthError(error.error, error.error_description)\n    }\n    if (error instanceof Error) {\n      return error\n    }\n    return new Error(fallbackMessage)\n  }\n\nexport const tokenError = normalizeErrorFn('Get access token failed')\n\n// For now we default to return the user to the root route after handling the redirect. At some point we could make it customizable.\nexport const defaultReturnTo = '/'\n\nexport const snakeToCamelCase = (str: string): string =>\n  str.replace(/([-_][a-z0-9])/gi, $1 => $1.toUpperCase().replace('_', ''))\n\n/**\n * Transform all object keys to camelCase including nested objects and arrays\n */\nexport function transformSnakeObjectKeysToCamel<INPUT extends {}>(\n  data: INPUT,\n): CamelCasedProperties<INPUT> {\n  return Object.fromEntries(\n    Object.entries(data).map(([key, val]) => [snakeToCamelCase(key), processVal(val)]),\n  ) as CamelCasedProperties<INPUT>\n}\n\n/** Utility function to transform recursively the value in the object */\nfunction processVal(val: unknown): unknown {\n  return typeof val !== 'object' || val === null\n    ? val\n    : Array.isArray(val)\n    ? val.map(processVal)\n    : transformSnakeObjectKeysToCamel(val)\n}\n","import { type AuthStore } from './authStore'\nimport type { AppState, Auth0User, User } from './types'\nimport { defaultReturnTo, transformSnakeObjectKeysToCamel } from './utils'\n\n/**\n * This is a policy function used to authorize a request in a loader function from react-router\n * @param authStore\n * @param callback\n * @param returnTo\n *\n * @example\n * ```js\n *  async function loader({ request }) {\n *      return authorize(\n *        authStore,\n *        async ({ user }) => {\n *          // here we can get the data for this route and return it.\n *        },\n *        '/welcome'\n *    )\n *  }\n * ```\n */\nexport const authorize = async <LoaderReturn = Response>(\n  authStore: AuthStore,\n  callback: (input: { user: User }) => Promise<LoaderReturn>,\n  returnTo = defaultReturnTo,\n) => {\n  const { user, loginWithRedirect, auth0Client, initialised } = authStore.getState()\n\n  try {\n    if (user) return await callback({ user })\n\n    await auth0Client.checkSession()\n    const auth0User = await auth0Client.getUser<Auth0User>()\n\n    if (!auth0User) throw new Error('Unauthorized')\n    initialised(auth0User)\n\n    return await callback({ user: transformSnakeObjectKeysToCamel(auth0User) })\n  } catch (error) {\n    return await loginWithRedirect({\n      appState: { returnTo },\n      onRedirect: async url => {\n        window.location.replace(url)\n        return new Promise(resolve => {\n          setTimeout(resolve, 1000)\n        })\n      },\n    })\n  }\n}\n\n/**\n * This is a policy function used to handle the redirection from Auth0\n * @param authStore\n * @param callback\n *\n * @example\n * ```js\n * // loader from route where Auth0 redirects users\n *  async function loader({ request }) {\n *      // handle other flows managed by the same route.\n *\n *      // handle default flow\n *      return handleRedirectCallback(authStore, async ({ appState }) => {\n *          return redirect(appState.returnTo)\n *      })\n *  }\n * ```\n */\nexport const handleRedirectCallback = async <LoaderReturn = Response>(\n  authStore: AuthStore,\n  callback: (input: { appState?: AppState }) => Promise<LoaderReturn>,\n) => {\n  const { auth0Client, initialised } = authStore.getState()\n\n  const { appState } = await auth0Client.handleRedirectCallback<AppState>()\n  const auth0User = await auth0Client.getUser<Auth0User>()\n  initialised(auth0User)\n\n  return callback({ appState })\n}\n"],"mappings":"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","names":["import_zustand"]}