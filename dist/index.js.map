{"version":3,"sources":["../src/index.ts","../src/AuthProvider.tsx","../src/errors.ts","../src/utils.ts","../src/authStore.ts","../src/loaderWithAuth.ts","../src/withAuthRequired.tsx"],"sourcesContent":["export { default as AuthProvider } from './AuthProvider'\nexport { createAuthStore } from './authStore'\nexport { loaderWithAuth } from './loaderWithAuth'\nexport { default as withAuthRequired } from './withAuthRequired'\nexport type {\n  Cacheable,\n  CacheLocation,\n  GetTokenSilentlyOptions,\n  GetTokenWithPopupOptions,\n  ICache,\n  IdToken,\n  InMemoryCache,\n  LocalStorageCache,\n  LogoutOptions,\n  LogoutUrlOptions,\n  PopupConfigOptions,\n  PopupLoginOptions,\n  User,\n} from '@auth0/auth0-spa-js'\nexport { default as createAuthHook } from 'zustand'\n","import { User } from '@auth0/auth0-spa-js'\nimport { ReactNode, useEffect, useRef } from 'react'\n\nimport { type AuthStore } from './authStore'\nimport { type AppState } from './types'\nimport { hasAuthParams } from './utils'\n\nexport type AuthProviderOptions = {\n  children: ReactNode\n  /**\n   * By default this removes the code and state parameters from the url when you are redirected from the authorize page.\n   * It uses `window.history` but you might want to overwrite this if you are using a custom router, like `react-router-dom`\n   * See the example folder.\n   */\n  onRedirectCallback?: (appState?: AppState, user?: User) => void\n  /**\n   * By default, if the page url has code/state params, the SDK will treat them as Auth0's and attempt to exchange the\n   * code for a token. In some cases the code might be for something else (another OAuth SDK perhaps). In these\n   * instances you can instruct the client to ignore them eg\n   *\n   * ```jsx\n   * <AuthProvider\n   *   clientId={clientId}\n   *   domain={domain}\n   *   skipRedirectCallback={window.location.pathname === '/stripe-oauth-callback'}\n   * >\n   * ```\n   */\n  skipRedirectCallback?: boolean\n  /**\n   * Zustand store that contains all the state and the different auth methods. Created with `createAuthStore`\n   *\n   * ```js\n   * const authStore = createAuthStore({\n   *  domain: import.meta.env.VITE_AUTH0_DOMAIN,\n   *  clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,\n   *  useRefreshTokens: true,\n   *  authorizationParams: {\n   *    audience: import.meta.env.VITE_AUTH0_AUDIENCE,\n   *    redirect_uri: window.location.origin,\n   *  },\n   * }\n   * ```\n   */\n  authStore: AuthStore\n}\n\nconst defaultOnRedirectCallback = (appState?: AppState): void => {\n  window.history.replaceState({}, document.title, appState?.returnTo || window.location.pathname)\n}\n\nconst AuthProvider = (opts: AuthProviderOptions) => {\n  const {\n    children,\n    skipRedirectCallback,\n    onRedirectCallback = defaultOnRedirectCallback,\n    authStore,\n  } = opts\n  const { auth0Client, initialised, setError } = authStore.getState()\n\n  const didInitialise = useRef(false)\n\n  useEffect(() => {\n    if (didInitialise.current) {\n      return\n    }\n    didInitialise.current = true\n    ;(async (): Promise<void> => {\n      try {\n        let user: User | undefined\n        if (hasAuthParams() && !skipRedirectCallback) {\n          const { appState } = await auth0Client.handleRedirectCallback()\n          user = await auth0Client.getUser()\n          initialised(user)\n          onRedirectCallback(appState, user)\n        } else {\n          await auth0Client.checkSession()\n          user = await auth0Client.getUser()\n          initialised(user)\n        }\n      } catch (error) {\n        setError(error as Error)\n      }\n    })()\n  }, [auth0Client, initialised, onRedirectCallback, setError, skipRedirectCallback])\n  return <>{children}</>\n}\n\nexport default AuthProvider\n","/**\n * An OAuth2 error will come from the authorization server and will have at least an `error` property which will\n * be the error code. And possibly an `error_description` property\n *\n * See: https://openid.net/specs/openid-connect-core-1_0.html#rfc.section.3.1.2.6\n */\nexport class OAuthError extends Error {\n  constructor(public error: string, public error_description?: string) {\n    super(error_description || error)\n\n    // https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n    Object.setPrototypeOf(this, OAuthError.prototype)\n  }\n}\n","import { OAuthError } from './errors'\n\nconst CODE_RE = /[?&]code=[^&]+/\nconst STATE_RE = /[?&]state=[^&]+/\nconst ERROR_RE = /[?&]error=[^&]+/\n\nexport const hasAuthParams = (searchParams = window.location.search): boolean =>\n  (CODE_RE.test(searchParams) || ERROR_RE.test(searchParams)) && STATE_RE.test(searchParams)\n\nconst normalizeErrorFn =\n  (fallbackMessage: string) =>\n  (error: Error | { error: string; error_description?: string } | ProgressEvent): Error => {\n    if ('error' in error) {\n      return new OAuthError(error.error, error.error_description)\n    }\n    if (error instanceof Error) {\n      return error\n    }\n    return new Error(fallbackMessage)\n  }\n\nexport const tokenError = normalizeErrorFn('Get access token failed')\n\nexport const defaultReturnTo = (): string => `${window.location.pathname}${window.location.search}`\n","import {\n  type Auth0ClientOptions,\n  type GetTokenSilentlyOptions,\n  type IdToken,\n  type LogoutOptions,\n  type RedirectLoginOptions,\n  type User,\n  Auth0Client,\n} from '@auth0/auth0-spa-js'\nimport { createStore } from 'zustand'\n\nimport { tokenError } from './utils'\n\ntype AuthState<TUser extends User = User> = {\n  auth0Client: Auth0Client\n  isLoading: boolean\n  isAuthenticated: boolean\n  error?: Error\n  user?: TUser\n  initialised: (user?: User) => void\n  setError: (error: Error) => void\n  loginWithRedirect: (loginOptions?: RedirectLoginOptions) => Promise<void>\n  logout: (logoutOptions?: LogoutOptions) => Promise<void>\n  getAccessTokenSilently: (getTokenOptions?: GetTokenSilentlyOptions) => Promise<string>\n  getIdTokenClaims: () => Promise<IdToken | undefined>\n}\n\n/**\n *  Function factory to create the Zustand store that contains all the state and the different auth methods.\n *  Use this store outside the React tree (ie. `const { isAuthenticated, loginWithRedirect } = authStore.getState()`)\n * ```js\n * const authStore = createAuthStore({\n *  domain: import.meta.env.VITE_AUTH0_DOMAIN,\n *  clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,\n *  useRefreshTokens: true,\n *  authorizationParams: {\n *    audience: import.meta.env.VITE_AUTH0_AUDIENCE,\n *    redirect_uri: window.location.origin,\n *  },\n * }\n *\n * Then you can use the `createAuthHook` function to create a custom hook for easy access inside React components\n * const useAuth = createAuthHook(authStore)\n * ```\n */\nexport const createAuthStore = (options: Auth0ClientOptions) =>\n  createStore<AuthState>()((set, get) => ({\n    isLoading: true,\n    isAuthenticated: false,\n    auth0Client: new Auth0Client(options),\n    initialised: user =>\n      set(state => ({\n        ...state,\n        isAuthenticated: !!user,\n        user,\n        isLoading: false,\n        error: undefined,\n      })),\n    setError: error => set(state => ({ ...state, isLoading: false, error })),\n    loginWithRedirect: loginOptions => {\n      const { auth0Client } = get()\n      return auth0Client.loginWithRedirect(loginOptions)\n    },\n    logout: logoutOptions => {\n      const { auth0Client } = get()\n      return auth0Client.logout(logoutOptions)\n    },\n    getAccessTokenSilently: async getTokenOptions => {\n      const { auth0Client } = get()\n      let token\n\n      try {\n        token = await auth0Client.getTokenSilently(getTokenOptions)\n      } catch (error) {\n        throw tokenError(error as Error)\n      } finally {\n        const user = await auth0Client.getUser()\n        set(state =>\n          state.user?.updated_at === user?.updated_at\n            ? state\n            : { ...state, isAuthenticated: !!user, user },\n        )\n      }\n      return token\n    },\n    getIdTokenClaims: () => {\n      const { auth0Client } = get()\n      return auth0Client.getIdTokenClaims()\n    },\n  }))\n\nexport type AuthStore = ReturnType<typeof createAuthStore>\n","import { RedirectLoginOptions } from '@auth0/auth0-spa-js'\n\nimport { type AuthStore } from './authStore'\nimport { defaultReturnTo } from './utils'\n\ntype LoaderWithAuthOptions = {\n  /**\n   * Zustand store that contains all the state and the different auth methods. Created with `createAuthStore`\n   *\n   * ```js\n   * const authStore = createAuthStore({\n   *  domain: import.meta.env.VITE_AUTH0_DOMAIN,\n   *  clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,\n   *  useRefreshTokens: true,\n   *  authorizationParams: {\n   *    audience: import.meta.env.VITE_AUTH0_AUDIENCE,\n   *    redirect_uri: window.location.origin,\n   *  },\n   * }\n   * ```\n   */\n  authStore: AuthStore\n  /**\n   * ```js\n   *  await loaderWithAuth({\n   *    loginOptions: {\n   *      appState: {\n   *        customProp: 'foo',\n   *      },\n   *    },\n   *  })\n   * ```\n   *\n   * Pass additional login options, like extra `appState` to the login page.\n   * This will be merged with the `returnTo` option used by the `onRedirectCallback` handler.\n   */\n  loginOptions?: RedirectLoginOptions\n  /**\n   * ```js\n   * await loaderWithAuth({ returnTo: () => window.location.hash.substr(1) })\n   * ```\n   * or\n   *\n   * ```js\n   * const returnTo = new URL(request.url).pathname\n   * await loaderWithAuth({ returnTo })\n   * ```\n   *\n   * Add a path for the `onRedirectCallback` handler to return the user to after login.\n   */\n  returnTo?: string | (() => string)\n}\n\n/**\n * ```js\n *  loader: async ({ request }: LoaderFunctionArgs) => {\n *    const returnTo = new URL(request.url).pathname\n *    await loaderWithAuth({ useAuth, returnTo });\n *    return json(SOME_DATA)\n *  }\n * ```\n *\n * When you call the function inside a route loader and an anonymous user is tring to access that route\n * they will be redirected to the login page and returned to the page they we're redirected from after login.\n */\nexport async function loaderWithAuth(options: LoaderWithAuthOptions) {\n  const { authStore, loginOptions, returnTo = defaultReturnTo } = options\n  const { isAuthenticated, loginWithRedirect } = authStore.getState()\n\n  if (!isAuthenticated) {\n    const opts = {\n      ...loginOptions,\n      appState: {\n        ...(loginOptions && loginOptions.appState),\n        returnTo: typeof returnTo === 'function' ? returnTo() : returnTo,\n      },\n    }\n    await loginWithRedirect(opts)\n  }\n}\n","import { RedirectLoginOptions, User } from '@auth0/auth0-spa-js'\nimport { ComponentType, useEffect } from 'react'\n\nimport { type AuthStore } from './authStore'\nimport { defaultReturnTo } from './utils'\n\nconst defaultOnRedirecting = () => <>Redirecting...</>\n\n/**\n * Options for the withAuthenticationRequired Higher Order Component\n */\nexport interface WithAuthenticationRequiredOptions {\n  /**\n   * ```js\n   * withAuthenticationRequired(Profile, {\n   *   returnTo: '/profile'\n   * })\n   * ```\n   *\n   * or\n   *\n   * ```js\n   * withAuthenticationRequired(Profile, {\n   *   returnTo: () => window.location.hash.substr(1)\n   * })\n   * ```\n   *\n   * Add a path for the `onRedirectCallback` handler to return the user to after login.\n   */\n  returnTo?: string | (() => string)\n  /**\n   * ```js\n   * withAuthenticationRequired(Profile, {\n   *   onRedirecting: () => <div>Redirecting you to the login...</div>\n   * })\n   * ```\n   *\n   * Render a message to show that the user is being redirected to the login.\n   */\n  onRedirecting?: () => JSX.Element\n  /**\n   * ```js\n   * withAuthenticationRequired(Profile, {\n   *   loginOptions: {\n   *     appState: {\n   *       customProp: 'foo'\n   *     }\n   *   }\n   * })\n   * ```\n   *\n   * Pass additional login options, like extra `appState` to the login page.\n   * This will be merged with the `returnTo` option used by the `onRedirectCallback` handler.\n   */\n  loginOptions?: RedirectLoginOptions\n  /**\n   * Check the user object for JWT claims and return a boolean indicating\n   * whether or not they are authorized to view the component.\n   */\n  claimCheck?: (claims?: User) => boolean\n  /**\n   * Zustand store that contains all the state and the different auth methods. Created with `createAuthStore`\n   *\n   * ```js\n   * const authStore = createAuthStore({\n   *  domain: import.meta.env.VITE_AUTH0_DOMAIN,\n   *  clientId: import.meta.env.VITE_AUTH0_CLIENT_ID,\n   *  useRefreshTokens: true,\n   *  authorizationParams: {\n   *    audience: import.meta.env.VITE_AUTH0_AUDIENCE,\n   *    redirect_uri: window.location.origin,\n   *  },\n   * }\n   * ```\n   */\n  authStore: AuthStore\n}\n\n/**\n * ```js\n * const MyProtectedComponent = withAuthenticationRequired(MyComponent);\n * ```\n *\n * When you wrap your components in this Higher Order Component and an anonymous user visits your component\n * they will be redirected to the login page and returned to the page they we're redirected from after login.\n */\nconst withAuthRequired = <P extends object>(\n  Component: ComponentType<P>,\n  options: WithAuthenticationRequiredOptions,\n) =>\n  function WithAuthenticationRequired(props: P): JSX.Element {\n    const {\n      authStore,\n      loginOptions,\n      returnTo = defaultReturnTo,\n      onRedirecting = defaultOnRedirecting,\n      claimCheck = (): boolean => true,\n    } = options\n\n    const { loginWithRedirect, isLoading, isAuthenticated, user } = authStore.getState()\n\n    /**\n     * The route is authenticated if the user has valid auth and there are no\n     * JWT claim mismatches.\n     */\n    const routeIsAuthenticated = isAuthenticated && claimCheck(user)\n\n    useEffect(() => {\n      if (isLoading || routeIsAuthenticated) {\n        return\n      }\n      const opts = {\n        ...loginOptions,\n        appState: {\n          ...(loginOptions && loginOptions.appState),\n          returnTo: typeof returnTo === 'function' ? returnTo() : returnTo,\n        },\n      }\n      ;(async (): Promise<void> => {\n        await loginWithRedirect(opts)\n      })()\n    }, [isLoading, routeIsAuthenticated, loginWithRedirect, loginOptions, returnTo])\n\n    return routeIsAuthenticated ? <Component {...props} /> : onRedirecting()\n  }\n\nexport default withAuthRequired\n"],"mappings":"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","names":["import_react","import_jsx_runtime","import_zustand"]}